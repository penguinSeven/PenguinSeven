(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{338:function(t,e,r){t.exports=r.p+"assets/img/Flowchart_showing_Simple_and_Preflight_XHR_wps.4f073497.png"},410:function(t,e,r){"use strict";r.r(e);var a=r(25),n=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"http"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[t._v("#")]),t._v(" http")]),t._v(" "),e("h2",{attrs:{id:"请求头"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请求头"}},[t._v("#")]),t._v(" 请求头")]),t._v(" "),e("h2",{attrs:{id:"响应头"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#响应头"}},[t._v("#")]),t._v(" 响应头")]),t._v(" "),e("h2",{attrs:{id:"常见问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见问题"}},[t._v("#")]),t._v(" 常见问题")]),t._v(" "),e("h3",{attrs:{id:"跨域共享-option请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#跨域共享-option请求"}},[t._v("#")]),t._v(" 跨域共享，option请求")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("流程\n"),e("img",{attrs:{src:r(338),alt:"圖片"}})])]),t._v(" "),e("li",[e("p",[t._v("跨域定义")])])]),t._v(" "),e("blockquote",[e("p",[t._v("浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域")])]),t._v(" "),e("ul",[e("li",[t._v("option请求")])]),t._v(" "),e("blockquote",[e("p",[t._v("在正式跨域的请求前，浏览器会根据需要，发起一个“PreFlight”（也就是Option请求），\n用来让服务端返回允许的方法（如get、post），被跨域访问的Origin（来源，或者域），\n还有是否需要Credentials(认证信息） 三种场景：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("1. 如果跨域的请求是Simple Request（简单请求 ），则不会触发“PreFlight”。 Mozilla对于简单请求的要求是： 以下三项必须都成立：\n\n2. 只能是Get、Head、Post方法\n\n3. 除了浏览器自己在Http头上加的信息（如Connection、User-Agent），开发者只能加这几个：Accept、Accept-Language、Content-Type、。。。。\n\n4. Content-Type只能取这几个值： application/x-www-form-urlencoded multipart/form-data text/plain\n")])])]),e("ul",[e("li",[t._v("总结")])]),t._v(" "),e("blockquote",[e("p",[t._v('XHR对象对于HTTP跨域请求有三种：简单请求、Preflighted 请求、Preflighted 认证请求。\n简单请求不需要发送OPTIONS嗅探请求，但只能按发送简单的GET、HEAD或POST请求，\n且不能自定义HTTP Headers。Preflighted 请求和认证请求，XHR会首先发送一个OPTIONS嗅探请求，\n然后XHR会根据OPTIONS请求返回的Access-Control-*等头信息判断是否有对指定站点的访问权限，\n并最终决定是否发送实际请求信息。 那么我的get请求呢？\n原来，产生 OPTIONS 请求的原因是：自定义 Headers 头信息导致的。\n浏览器会去向 Server 端发送一个 OPTIONS 请求，\n看 Server 返回的 "Access-Control-Allow-Headers"\n是否有自定义的 header 字段。因为我之前没有返回自定义的字段，\n所以，默认是不允许的，造成了客户端没办法拿到数据。')])]),t._v(" "),e("p",[e("a",{attrs:{href:"https://www.cnblogs.com/xiaozengzeng/p/10852224.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("引用:一次跨域请求出现 OPTIONS 请求的问题及解决方法"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://blog.csdn.net/u012207345/article/details/81449683",target:"_blank",rel:"noopener noreferrer"}},[t._v("CORS 跨域中的 preflight 请求"),e("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=n.exports}}]);